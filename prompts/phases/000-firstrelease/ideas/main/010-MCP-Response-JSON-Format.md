# 010: MCP Response JSON Format — Align with OpenAPI

## Background

Currently, the MCP adapter returns plain text representations for both success and error responses, while the HTTP/CGI adapters return structured JSON. This inconsistency means that consumers of the same function get different response formats depending on the transport.

| Scenario | MCP (current) | HTTP/CGI |
|---|---|---|
| Single return value | `"10"` (plain text via `fmt.Sprintf`) | `{"result": 10}` (JSON) |
| Multiple return values | `"[10 20]"` (Go default format) | `{"result0": 10, "result1": 20}` (JSON) |
| Error | `"Error: ..."` (plain text) | Plain text via `http.Error` / CGI status line |

The MCP response format is not machine-parseable, loses type information (e.g., integers become strings), and does not match the OpenAPI response schema generated by `GenerateOutputJSONSchema`.

Additionally, HTTP/CGI error responses are also plain text, which is inconsistent with the JSON success responses and the OpenAPI specification.

## Requirements

### Mandatory

1. **MCP success response**: The `TextContent.Text` field must contain a JSON string matching the same structure as the HTTP/CGI adapter response.
   - Single return value: `{"result": <value>}`
   - Multiple return values: `{"result0": <value0>, "result1": <value1>, ...}`
   - No return values (error-only function): `{}`

2. **MCP error response**: The `TextContent.Text` field must contain a JSON string with a standardized error format when `IsError` is `true`.
   - Format: `{"error": "<error message>"}`
   - This applies to both argument parsing errors and function execution errors.

3. **HTTP error response**: Error responses from the HTTP adapter (`adapter_http.go`) must use JSON format with `Content-Type: application/json` instead of plain text from `http.Error`.
   - Format: `{"error": "<error message>"}` with the appropriate HTTP status code.

4. **CGI error response**: Error responses from the CGI adapter (`adapter_cgi.go`) must use JSON format with `Content-Type: application/json` in the CGI headers.
   - Format: `{"error": "<error message>"}` with the appropriate CGI Status.

5. **OpenAPI error schema**: The OpenAPI specification generated by `generateOpenAPISpec` must include error response definitions (400, 500) with the JSON error schema.

6. **Backward compatibility of response structure**: The success response JSON structure (`{"result": ...}` / `{"result0": ..., ...}`) must remain unchanged for HTTP/CGI adapters.

### Optional

7. **Shared response builder**: Extract the response JSON construction logic (success and error) into a shared helper so all adapters (HTTP, CGI, MCP) use the same code path, reducing duplication.

## Implementation Approach

### Response Builder (shared helper)

Create shared functions in a new or existing file (e.g., `response.go`) to build both success and error response maps:

```go
// buildSuccessResponse constructs the standard response map from function results.
func buildSuccessResponse(results []any) map[string]any {
    response := make(map[string]any)
    if len(results) == 1 {
        response["result"] = results[0]
    } else {
        for i, res := range results {
            response[fmt.Sprintf("result%d", i)] = res
        }
    }
    return response
}

// buildErrorResponse constructs the standard error response map.
func buildErrorResponse(msg string) map[string]any {
    return map[string]any{"error": msg}
}
```

### MCP Adapter Changes (`adapter_mcp.go`)

- **Success path** (lines 66–77): Replace `fmt.Sprintf("%v", ...)` with JSON marshaling of the response map from `buildSuccessResponse`.
- **Error paths** (lines 42–47, 58–63): Marshal `buildErrorResponse(msg)` to JSON and set as `TextContent.Text`.

### HTTP Adapter Changes (`adapter_http.go`)

- **Error paths** (lines 46–48, 53–54, 58–60): Replace `http.Error(...)` calls with JSON-encoded error responses using `buildErrorResponse`, setting `Content-Type: application/json` and writing the appropriate status code.
- **Success path** (lines 66–73): Refactor to use `buildSuccessResponse`.

### CGI Adapter Changes (`adapter_cgi.go`)

- **Error paths** (lines 46, 58, 68): Replace plain text error output with JSON-formatted error responses using `buildErrorResponse`, including `Content-Type: application/json` in CGI headers.
- **Success path** (lines 75–82): Refactor to use `buildSuccessResponse`.

### OpenAPI Spec Changes (`openapi.go`)

Add error response schemas to the generated specification:

```json
"400": {
  "description": "Invalid request",
  "content": {
    "application/json": {
      "schema": {
        "type": "object",
        "properties": {
          "error": { "type": "string" }
        },
        "required": ["error"]
      }
    }
  }
},
"500": {
  "description": "Internal server error",
  "content": {
    "application/json": {
      "schema": {
        "type": "object",
        "properties": {
          "error": { "type": "string" }
        },
        "required": ["error"]
      }
    }
  }
}
```

### File Summary

| File | Change |
|---|---|
| `response.go` (new) | Shared `buildSuccessResponse` and `buildErrorResponse` helpers |
| `adapter_mcp.go` | Use JSON for both success and error responses |
| `adapter_http.go` | Use JSON for error responses, refactor success to use shared helper |
| `adapter_cgi.go` | Use JSON for error responses, refactor success to use shared helper |
| `openapi.go` | Add 400/500 error response schemas |
| `tests/kuniumi/kuniumi_test.go` | Update assertions to match new response formats |

## Verification Scenarios

### Scenario 1: MCP success response is JSON

1. Build the example app.
2. Connect an MCP client to the built binary via `mcp` subcommand.
3. Call `functions.Add` with `{"x": 7, "y": 3}`.
4. Verify `IsError` is `false`.
5. Verify `Content[0]` is `TextContent` and `Text` is `{"result":10}`.
6. Parse the `Text` as JSON and confirm `result` equals `10` (integer).

### Scenario 2: MCP error response is JSON

1. Build the example app.
2. Connect an MCP client via `mcp` subcommand.
3. Call `functions.Add` with invalid arguments (e.g., `{"x": "not_a_number", "y": 3}`).
4. Verify `IsError` is `true`.
5. Verify `Content[0].Text` is valid JSON matching `{"error": "<message>"}`.

### Scenario 3: HTTP error response is JSON

1. Start the example app with `serve --port 9999`.
2. POST invalid JSON to `/functions/Add`.
3. Verify HTTP status is 400.
4. Verify response body is `{"error": "Invalid JSON body"}` with `Content-Type: application/json`.

### Scenario 4: CGI error response is JSON

1. Execute the binary with `cgi` subcommand, `PATH_INFO=/NonExistent`, `REQUEST_METHOD=POST`.
2. Verify CGI output contains `Status: 404 Not Found` and `Content-Type: application/json`.
3. Verify the body is JSON matching `{"error": "Function not found: NonExistent"}`.

### Scenario 5: OpenAPI spec includes error schemas

1. Retrieve the OpenAPI spec via `/openapi.json`.
2. Verify each path operation includes `400` and `500` response definitions.
3. Verify the error response schema contains `{"type": "object", "properties": {"error": {"type": "string"}}}`.

### Scenario 6: Existing success responses unchanged

1. Verify HTTP POST to `/functions/Add` with `{"x": 5, "y": 5}` returns `{"result": 10}`.
2. Verify CGI execution with the same input returns `{"result": 30}` (for `x=10, y=20`).

## Testing for the Requirements

| Requirement | Verification | Script/Test |
|---|---|---|
| Req 1: MCP success JSON | Scenario 1 — `TestKuniumiIntegration/MCP/CallTool` asserts JSON response | `scripts/process/integration_test.sh` |
| Req 2: MCP error JSON | Scenario 2 — `TestKuniumiIntegration/MCP/CallToolError` asserts JSON error | `scripts/process/integration_test.sh` |
| Req 3: HTTP error JSON | Scenario 3 — `TestKuniumiIntegration/Serve/ErrorResponse` asserts JSON error with status code | `scripts/process/integration_test.sh` |
| Req 4: CGI error JSON | Scenario 4 — `TestKuniumiIntegration/CGI/ErrorResponse` asserts JSON error | `scripts/process/integration_test.sh` |
| Req 5: OpenAPI error schema | Scenario 5 — `assertValidOpenAPISpec` checks 400/500 response schemas | `scripts/process/integration_test.sh` |
| Req 6: Backward compat | Scenario 6 — Existing `Serve/FunctionCall` and `CGI` tests pass unchanged | `scripts/process/integration_test.sh` |
| Req 7: Shared helper | Unit test for `buildSuccessResponse` and `buildErrorResponse` | `scripts/process/build.sh` (unit tests) |
| All | Full build + test pipeline | `scripts/process/build.sh && scripts/process/integration_test.sh` |
